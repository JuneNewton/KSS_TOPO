"use-struct";const path=require("path"),fs=require("fs"),KSLMQManager=require("ksl-mqtt"),mqOperateType=require("ksl-common").MQ_OPERATE_TYPE,SUBSCRIBE_PUBLISH_CONFIG_FILE="../../Config/subscribe_publish_info.json",{Worker:Worker,threadId:threadId}=require("worker_threads"),logger=require("ksl-log-helper").logger,WORKER_THREAD_NUM=1;let heartStatus=0,topicInfoMap=new Map,logLevel="info";function isSubscribePublishConfigEmpty(){if(0===topicInfoMap.size){try{let e=JSON.parse(fs.readFileSync(path.join(__dirname,SUBSCRIBE_PUBLISH_CONFIG_FILE),"utf-8"));for(let r of Object.keys(e)){let o=new Map;for(let t of Object.keys(e[r]))o.set(t,e[r][t]);topicInfoMap.set(r,o)}}catch(e){logger.error("Read Subscribe and Publish Config Error->"+e)}return!0}return!1}function saveSubscribePublishInfo(){let e={};for(let[r,o]of topicInfoMap){let t={};for(let[e,r]of o)t[e]=r;e[r]=t}try{fs.writeFileSync(path.join(__dirname,SUBSCRIBE_PUBLISH_CONFIG_FILE),JSON.stringify(e),"utf-8")}catch(e){logger.error("Write Subscribe and Publish Error->"+e)}}function readInnerEMQCfg(e){let r=!0;try{let o=e.ip,t=e.port;if(void 0===o||void 0===t)return logger.error("The Inner emqCfgFile IP or Port is Undefined! IP->"+o+" port->"+t),r=!1;let a=e.anonymite,s=e.userName,i=e.password;otherServiceSubscribeManagerObj=new KSLMQManager(o,t,{anonymite:a,username:s,password:i})}catch(e){logger.error("Alarm Process Error!->"+e.message),r=!1}return r}function recvFromWorker(e){let r=e.msg;if(r)for(let e of Object.keys(r))otherServiceSubscribeManagerObj.handleMQOperate(mqOperateType.PUBLISH,r[e]);else logger.error("The Result of Analysis Data is Empty! Topic->"+key)}function createAllWorkerObj(){for(let e=0;e<WORKER_THREAD_NUM;++e)createSingleWorkerObj(e)}function createSingleWorkerObj(e){if(e<0||e>WORKER_THREAD_NUM)return void logger.error("Parse Alarm Process: ID out of the Limit Value->"+e);let r={};r.logLevel=logLevel,worker[e]=new Worker(path.join(__dirname+"/ksl_parse_alarm.js"),{workerData:r}),worker[e].on("message",e=>{recvFromWorker(e)}),worker[e].on("error",r=>{logger.error("Parse Alarm Worker Error! ID->"+e+" Error->"+r),createSingleWorkerObj(e)}),worker[e].on("exit",r=>{logger.warn("Parse Alarm Worker Exit! ID->"+e+" Code->"+r)})}function removeTopicInfo(e){topicInfoMap.has(e)&&topicInfoMap.delete(e)}worker=[],otherServiceSubscribeManagerObj=void 0,process.on("SIGTERM",e=>{logger.warn(`Alarm process recv signal:${e}`),process.exit()}),process.on("message",e=>{if("object"==typeof e)if(e.hasOwnProperty("cfg"))readInnerEMQCfg(e.cfg),logLevel=e.logLevel,logger.setLevel(logLevel),createAllWorkerObj();else if(e.hasOwnProperty("heartbeat"))"pong"===e.heartbeat&&(heartStatus=0,logger.debug("alarm process rec pong"));else{let r=e.topic;if(r.startsWith("alarm_subscribe/")){let o=e.msg;if("object"!=typeof o)return void logger.error("The Data is not object!");let t=o.From;if(void 0===t)return void logger.error("The From is not object!");console.log("addTopicInfo topic => "+r+" From->"+t+" Data->"+JSON.stringify(o));let a=new Map;topicInfoMap.get(r)&&(a=topicInfoMap.get(r)),a.set(t,o),topicInfoMap.set(r,a),saveSubscribePublishInfo()}else{isSubscribePublishConfigEmpty()&&logger.info("Collect Server has Restart");for(let[r,o]of topicInfoMap){let t={};t.unhandledDataObj=e.msg,t.topic=r,t.subscribeTopicObj=o;let a=Math.floor(Math.random()*WORKER_THREAD_NUM);worker[a].postMessage(t)}}}}),setInterval(()=>{5<(heartStatus+=1)&&process.exit(),process.send({heartbeat:"ping"})},1e4);